## 第 1 章 权衡的艺术

### 1.1 命令式和声明式

1. 命令式 关注过程
2. 声明式 关注结果
3. 原生的性能最好，但是可维护性差
4. 框架的性能稍差，但是可维护性好

## 第 2 章 框架设计的核心要素

### 2.1 提升用户体验

1. 框架设计和开发需要提供友好的告警信息

### 2.2 控制框架代码的体积

1. vue.js 在输出资源时，会输出两个版本，一个用于开发环境，如 vue.global.js，一个用于生产环境，如 vue.global.prod.js。
2. 不会执行的代码称为 dead code，不会出现在最终的产物中，在构建资源时会被移除，所以 dead code 不会出现在 vue.global.prod.js 中，这样可以在开发环境中为用户提供友好告警信息的同时，不会增加生产环境的代码。

### 2.3 框架要做到良好的 Tree-Shaking

1. Tree-Shaking 就是消除那些永远不会被执行的代码，也就是排除 dead code。
2. 实现 Tree-Shaking 必须满足一个条件，模块必须是 ESM(ES Module)，因为 Tree-Shaking 依赖 ESM 的静态结构。
3. 如果一个函数调用会产生副作用，那就不能将其移除。副作用就是当调用函数的时候会对外部产生影响。
4. <code>`/*#_PURE_*/`</code>是用来告诉 rollup.js 或 webpack 代码不会产生副作用，可以进行 Tree-Shaking。通常产生副作用的代码都是模块内函数的顶级调用。

```js
foo(); //顶级调用
function bar() {
  foo(); // 函数内调用
}
```

### 2.4 框架应该输出怎样的构建产物

1. vue.js 的构建产物除了有环境上的区别之外，还会根据使用场景的不同而输出其它形式的产物。
2. 如果用户希望可以直接在 HTML 页面中使用`<script>`标签引入框架并使用，需要输出 IIFE 格式的资源，

```js
<body>
  <script src="vue.js"></script>
  <script>const {createApp} = Vue // ...</script>
</body>
```

3. vue.global.js 文件就是 IIFE 形式的资源
4. 无论是 rollup 还是 webpack，在寻找资源时，package.json 中如果存在 module 字段，那会优先使用 module 字段指向的资源来代替 main 字段指向的资源。
5. 带有-bundler 字样的 ESM 资源是给 rollup 或 webpack 打包工具使用的，而带有-browser 字样的 ESM 资源是直接给`<script type="module">`使用的。
6. ESM 格式的资源有两种：用于浏览器的 esm-browser.js 和用于打包工具的 esm-bundler.js。他们的区别在于对预定义常量*DEV*的处理，前者直接将*DEV*常量替换为字面量 true 或 false，后者将*DEV*常量替换为 process.env.NODE_ENV!='production'语句。

### 2.5 特性开关

1. 对于用户关闭的特性开关，可以利用 Tree-Shaking 机制让其不包含在最终的资源中。

## 第 3 章 Vue.js3 的设计思路

### 3.1 声明式地描述 UI

1. 使用 JavaScript 对象描述 UI 的方式，就是所谓的虚拟 DOM。
2. 一个组件渲染的内容是通过 render()渲染函数来描述的，vue.js 会根据组件的 render()函数的返回值拿到虚拟 DOM，然后把组件内容渲染出来。

### 3.2 初识渲染器
1. 渲染器的作用就是把虚拟DOM渲染成真实的DOM。
2. 渲染器renderer的实现思路：
- 创建元素：把vnode.tag作为标签名称来创建DOM元素。
- 为元素添加属性和事件：遍历vnode.props对象，如果key以on字符开头，把字符on截取后再调用toLowerCase函数将事件名小写化，得到合法事件名称，最后调用addEventListener绑定事件处理函数。
- 处理children：如果children是一个数组，递归调用renderer继续渲染，此时需要把刚刚创建的元素作为挂载点（父节点），如果children是字符串，使用createTextNode函数创建一个文本节点，并将其添加到新创建的元素内。

### 3.3 组件的本质
1. 组件是一组DOM元素的封装，这组DOM元素就是组件要渲染的内容，可以定义一个函数代表组件，而函数的返回值代表组件要渲染的内容。组件的返回值也是虚拟DOM。

### 3.4 模版的工作原理
1. 编译器的作用就是将模版编译为渲染函数，并添加到`<script>`标签块的组件对象上。
2. 无论是使用模版还是直接手写渲染函数，对于一个组件来说，它要渲染的内容最终都是通过渲染函数产生的，然后渲染器再把渲染函数返回的虚拟DOM渲染为真实的DOM，这是模版的工作原理，也是vue.js渲染页面的流程。

### 3.5 Vue.js是由各个模版组成的有机整体
1. 虚拟DOM比模版更加灵活，但模版比虚拟DOM更加直观。
2. 编译器是一个返回虚拟DOM的函数或对象。
3. 渲染器是将虚拟DOM渲染成真实的DOM，通过diff算法找出更新点。
4. 编译器和渲染器的交流媒介就是虚拟DOM，编译器通过添加属性标志，告诉渲染器怎么区分动态属性和静态属性，以及更新点。

## 第 4 章 响应系统的作用与实现
### 4.1 响应式数据与副作用函数
1. 副作用函数：指会产生副作用的函数。比如一个函数的执行会影响其它函数的执行，一个函数修改了去全局变量。

### 4.2 响应式数据的基本实现
1. 当读取操作发生时，将副作用函数收集到桶中
2. 当设置操作发生时，从桶中取出副作用函数并执行

### 4.3 设计一个完善的响应式系统
1. 